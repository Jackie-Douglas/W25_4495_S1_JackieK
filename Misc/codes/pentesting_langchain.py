import subprocess
import json
import os
import time
import threading
import logging
import re
from http.server import SimpleHTTPRequestHandler, HTTPServer
from langchain_openai import OpenAI
from langchain.prompts import PromptTemplate

openai_api_key = "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"  # Ensure you securely handle your API key

OUTPUT_FILE = "output.html"
ANALYSIS_FILE = "analysis.html"
PORT = 8000
TARGETS = []
THREAD_COUNT = 5

# Define the LLM model with OpenAI
llm = OpenAI(model="gpt-3.5-turbo", openai_api_key=openai_api_key)

# Define the prompt template
prompt = PromptTemplate(
    template="""Given the following vulnerability findings, suggest a detailed remediation plan:

Vulnerability Category: {category}
Severity: {severity}
Affected File(s): {files}
Vulnerable Line(s): {lines}

Remediation steps:
""",
    input_variables=["category", "severity", "files", "lines"]
)

# Create the LangChain analysis chain
chain = prompt | llm

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

def run_command(command, category):
    start_time = time.time()
    print(f"[+] Running command: {command}")
    try:
        result = subprocess.run(command, shell=True, check=True, text=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        output = result.stdout
    except subprocess.CalledProcessError as e:
        output = f"Error executing command: {e}"

    end_time = time.time()
    duration = end_time - start_time
    print(f"    - Start: {time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(start_time))}")
    print(f"    - End: {time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(end_time))}")
    print(f"    - Duration: {duration:.2f} seconds\n")

    with open(OUTPUT_FILE, "a") as f:
        f.write(f"\n<h2>{category}</h2><pre>{output}</pre>\n")
    
    return output

def validate_target(target):
    ip_pattern = r"^(?:[0-9]{1,3}\.){3}[0-9]{1,3}(:\d+)?$"
    domain_pattern = r"^(?:[a-zA-Z0-9-]+\.)+[a-zA-Z]{2,}(:\d+)?$"
    return re.match(ip_pattern, target) or re.match(domain_pattern, target)

def generate_html_report(content):
    return f"""<html><head><title>Penetration Test Output</title></head><body>{content}</body></html>"""

def generate_analysis():
    # Read the output data from the HTML report
    with open(OUTPUT_FILE, "r") as f:
        output_data = f.read()

    # Create analysis using LangChain based on the gathered output data
    try:
        analysis = chain.invoke({"category": "Pentest Report", "severity": "High", "files": "N/A", "lines": output_data})
        with open(ANALYSIS_FILE, "w") as f:
            f.write(generate_html_report(f"<h1>Analysis Report</h1><pre>{analysis}</pre>"))
    except Exception as e:
        logging.error(f"Error generating analysis: {e}")
        with open(ANALYSIS_FILE, "w") as f:
            f.write(generate_html_report("<h1>Analysis Report</h1><pre>Analysis generation failed due to an error.</pre>"))

def run_server():
    handler = SimpleHTTPRequestHandler
    os.chdir(os.path.dirname(os.path.abspath(OUTPUT_FILE)))
    httpd = HTTPServer(('localhost', PORT), handler)
    print(f"Serving reports at: http://localhost:{PORT}/output.html and http://localhost:{PORT}/analysis.html")
    httpd.serve_forever()

def scan_target(target):
    if not validate_target(target):
        logging.error(f"Invalid target: {target}")
        return
    
    categories = {
        "Host & Network Scanning": [
            f"nmap -sn {target}",
            f"nmap -p- -T4 {target}",
            f"sudo nmap -O -A {target}",
            f"nmap -f --mtu 16 {target}"
        ],
        "Web & DNS Enumeration": [
            f"nmap --script=http-title,http-headers,http-methods -p 80,443 {target}",
            f"nmap --script=dns-brute,dns-zone-transfer -p 53 {target}",
            f"whatweb {target}",
            f"nikto -h {target}",
            f"nikto -h {target} -ssl"
        ],
        "Vulnerability Scanning": [
            f"nmap --script=vulners -sV {target}",
            "cd Sn1per && sudo sniper -t {target} -m full && cd .."
        ],
        "SQL Injection Testing (Optimized)": [
            f"sqlmap -u \"{target}\" --dbs --batch --level=1 --risk=1"
        ],
        "Credential Brute-Forcing": [
            f"proxychains hydra -L /usr/share/wordlists/metasploit/common_roots.txt -P /usr/share/wordlists/rockyou.txt -t 1 -w 5 {target} ssh",
            f"proxychains hydra -L /usr/share/wordlists/metasploit/common_roots.txt -P /usr/share/wordlists/rockyou.txt -t 1 -w 5 {target} ftp",
            f"proxychains hydra -L /usr/share/wordlists/metasploit/common_roots.txt -P /usr/share/wordlists/rockyou.txt -t 1 -w 5 {target} rdp",
            f"hydra -l admin -P /usr/share/wordlists/rockyou.txt {target} https-post-form \"/users/sign_in:email=^USER^&password=^PASS^:F=Invalid email or password.\""
        ],
        "Cross-Site Scripting (XSS) Testing": [
            f"xsser -u \"{target}\" -c 100 â€“Cl"
        ]
    }

    for category, commands in categories.items():
        print(f"\n[+] Running {category} on {target}...")
        for cmd in commands:
            run_command(cmd, category)

def multi_threaded_scan():
    threads = []
    for target in TARGETS:
        thread = threading.Thread(target=scan_target, args=(target,))
        threads.append(thread)
        thread.start()
        if len(threads) >= THREAD_COUNT:
            for t in threads:
                t.join()
            threads.clear()
    for t in threads:
        t.join()

def main():
    global TARGETS
    targets_input = input("Enter target IPs or domains (comma-separated): ")
    TARGETS = [t.strip() for t in targets_input.split(',')]
    
    with open(OUTPUT_FILE, "w") as f:
        f.write(generate_html_report("<h1>Initial Penetration Test Output</h1>"))

    multi_threaded_scan()
    
    with open(OUTPUT_FILE, "a") as f:
        f.write("</body></html>")

    # Generate analysis report using LangChain
    generate_analysis()

    # Start the server to host the reports
    threading.Thread(target=run_server, daemon=True).start()
    print(f"\nReports generated. Access them at:\n- Output: http://localhost:{PORT}/output.html\n- Analysis: http://localhost:{PORT}/analysis.html")

if __name__ == "__main__":
    main()
