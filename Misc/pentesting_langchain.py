import subprocess
import json
import os
import time
import threading
import logging
import re
from http.server import SimpleHTTPRequestHandler, HTTPServer
from langchain_openai import OpenAI
from langchain.prompts import PromptTemplate

# Directly include your OpenAI API key here
openai_api_key = "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"

OUTPUT_FILE = "output.html"
ANALYSIS_FILE = "analysis.html"
PORT = 8000
TARGETS = []  # List of targets for multi-target scanning
THREAD_COUNT = 5  # Number of threads for parallel execution

# Initialize OpenAI model with the API key
llm = OpenAI(model="text-davinci-003", openai_api_key=openai_api_key)

# LangChain remediation prompt
template = """
Given the following vulnerability findings, suggest a detailed remediation plan:

Vulnerability Category: {category}
Severity: {severity}
Affected File(s): {files}
Vulnerable Line(s): {lines}

Remediation steps:
"""

# Correct template definition
prompt = PromptTemplate(template=template, input_variables=["category", "severity", "files", "lines"])

# Chain prompt and LLM with the `|` operator
chain = prompt | llm

# Set up logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

def run_command(command):
    start_time = time.time()
    try:
        result = subprocess.run(command, shell=True, check=True, text=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        output = result.stdout
        logging.info(f"Command executed successfully: {command}")
    except subprocess.CalledProcessError as e:
        logging.error(f"Error executing command: {e}")
        output = f"Error executing command: {e}"

    end_time = time.time()
    duration = end_time - start_time

    log_entry = f"\n[✔] Command: {command}\n"
    log_entry += f"    - Start: {time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(start_time))}\n"
    log_entry += f"    - End: {time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(end_time))}\n"
    log_entry += f"    - Duration: {duration:.2f} seconds\n"
    log_entry += f"    - Output:\n{output}\n"

    with open(OUTPUT_FILE, "a") as f:
        f.write(log_entry)

    return output

def validate_target(target):
    """Validates target IPs or domains with optional port."""
    ip_pattern = r"^(?:[0-9]{1,3}\.){3}[0-9]{1,3}(:\d+)?$"  # Updated to allow port numbers
    domain_pattern = r"^(?:[a-zA-Z0-9-]+\.)+[a-zA-Z]{2,}(:\d+)?$"  # Updated to allow port numbers
    if re.match(ip_pattern, target) or re.match(domain_pattern, target):
        return True
    return False

def generate_html_report(content):
    """Generates an HTML formatted report."""
    return f"""<html><head><title>Penetration Test Output</title></head><body><h1>Penetration Test Output</h1><pre>{content}</pre></body></html>"""

def generate_analysis():
    """Generates an HTML remediation analysis report."""
    with open(OUTPUT_FILE, "r") as f:
        output_data = f.read()
    analysis = chain.invoke({
        "category": "Pentest Report", 
        "severity": "High", 
        "files": "N/A", 
        "lines": output_data
    })
    with open(ANALYSIS_FILE, "w") as f:
        f.write(generate_html_report(f"<h1>Analysis Report</h1><pre>{analysis}</pre>"))

def run_server():
    """Starts a local HTTP server for report viewing."""
    handler = SimpleHTTPRequestHandler
    os.chdir(os.path.dirname(os.path.abspath(OUTPUT_FILE)))
    httpd = HTTPServer(('localhost', PORT), handler)
    print(f"Serving reports at: http://localhost:{PORT}/output.html and http://localhost:{PORT}/analysis.html")
    httpd.serve_forever()

def scan_target(target):
    """Runs security scans for a given target."""
    if not validate_target(target):
        logging.error(f"Invalid target: {target}")
        return
    
    categories = {
        "Host & Network Scanning": [
            f"nmap -sn {target}",
            f"nmap -p- -T4 {target}",
            f"sudo nmap -O -A {target}",
            f"nmap -f --mtu 16 {target}"
        ],
        "Web & DNS Enumeration": [
            f"nmap --script=http-title,http-headers,http-methods -p 80,443 {target}",
            f"nmap --script=dns-brute,dns-zone-transfer -p 53 {target}",
            f"whatweb {target}",
            f"nikto -h {target}",
            f"nikto -h {target} -ssl"
        ],
        "Vulnerability Scanning": [
            f"nmap --script=vulners -sV {target}",
            "cd Sn1per && sudo sniper -t {target} -m full && cd .."
        ],
        "SQL Injection Testing": [
            f"sqlmap -u \"{target}\" --crawl=2 --dbs --random-agent",
            f"sqlmap -u \"{target}\" –passwords",
            f"sqlmap -u \"{target}\" --forms --crawl=3 --risk=3 --level=5 --tamper=space2comment,charencode --random-agent --batch"
        ],
        "Credential Brute-Forcing": [
            f"proxychains hydra -L /usr/share/wordlists/metasploit/common_roots.txt -P /usr/share/wordlists/rockyou.txt -t 1 -w 5 {target} ssh",
            f"proxychains hydra -L /usr/share/wordlists/metasploit/common_roots.txt -P /usr/share/wordlists/rockyou.txt -t 1 -w 5 {target} ftp",
            f"proxychains hydra -L /usr/share/wordlists/metasploit/common_roots.txt -P /usr/share/wordlists/rockyou.txt -t 1 -w 5 {target} rdp",
            f"hydra -l admin -P /usr/share/wordlists/rockyou.txt {target} https-post-form \"/users/sign_in:email=^USER^&password=^PASS^:F=Invalid email or password.\""
        ],
        "Cross-Site Scripting (XSS) Testing": [
            f"xsser -u \"{target}\" -c 100 –Cl"
        ]
    }

    for category, commands in categories.items():
        print(f"\n[+] Running {category} on {target}...")
        with open(OUTPUT_FILE, "a") as f:
            f.write(f"\n\n### {category} - {target} ###\n\n")
        for cmd in commands:
            run_command(cmd)

def multi_threaded_scan():
    """Executes scans using multiple threads."""
    threads = []
    for target in TARGETS:
        thread = threading.Thread(target=scan_target, args=(target,))
        threads.append(thread)
        thread.start()
        if len(threads) >= THREAD_COUNT:
            for t in threads:
                t.join()
            threads.clear()  # Reset the list to start new threads
    # Join remaining threads after finishing all target scans
    for t in threads:
        t.join()

def main():
    """Main function to start scanning."""
    global TARGETS
    targets_input = input("Enter target IPs or domains (comma-separated): ")
    TARGETS = [t.strip() for t in targets_input.split(',')]
    
    with open(OUTPUT_FILE, "w") as f:
        f.write(generate_html_report("Initial Penetration Test Output"))

    multi_threaded_scan()
    
    with open(OUTPUT_FILE, "a") as f:
        f.write("</pre></body></html>")
    
    generate_analysis()
    threading.Thread(target=run_server, daemon=True).start()
    print(f"\nReports generated. Access them at:\n- Output: http://localhost:{PORT}/output.html\n- Analysis: http://localhost:{PORT}/analysis.html")

if __name__ == "__main__":
    main()
